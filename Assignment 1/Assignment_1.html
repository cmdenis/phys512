<!DOCTYPE html>
<html>
<head>
<title>Assignment_1.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="assignment-1">Assignment 1</h1>
<p>By Christian Mauffette Denis</p>
<p>For PHYS-512</p>
<h2 id="question-1">Question 1</h2>
<h3 id="a">a)</h3>
<p>We want to compute the derivative using the given 4 points. We know that</p>
<p>$$f(x + \delta) = f(x) + f'(x) \delta + \frac{f''(x)}{2}\delta^2 + \frac{f'''(x)}{6}\delta^3 + \frac{f^{(4)}(x)}{24}\delta^4 + \frac{f^{(5)}(x)}{120}\delta^5 + ...  $$</p>
<p>$$f(x - \delta) = f(x) - f'(x) + \frac{f''(x)}{2}\delta^2 - \frac{f'''(x)}{6}\delta^3 + \frac{f^{(4)}(x)}{24}\delta^4 - \frac{f^{(5)}(x)}{120}\delta^5 + ...  $$</p>
<p>$$f(x + 2\delta) = f(x) + 2 f'(x) \delta + \frac{4 f''(x)}{2}\delta^2 + \frac{8 f'''(x)}{6}\delta^3 + \frac{16 f^{(4)}(x)}{24}\delta^4 + \frac{32 f^{(5)}(x)}{120}\delta^5 + ...  $$</p>
<p>$$f(x - 2\delta) = f(x) - 2 f'(x) \delta + \frac{4 f''(x)}{2}\delta^2 - \frac{8 f'''(x)}{6}\delta^3 + \frac{16 f^{(4)}(x)}{24}\delta^4 - \frac{32 f^{(5)}(x)}{120}\delta^5 + ...  $$</p>
<p>If we subtract the first two expression we get:</p>
<p>$$f(x + \delta) - f(x - \delta) = 2 f'(x) \delta + \frac{ 2 f'''(x)}{6}\delta^3 + \frac{2 f^{(5)}(x)}{120}\delta^5 + ...  $$</p>
<p>$$ = 2 f'(x) \delta + \frac{ f'''(x)}{3}\delta^3 + \frac{ f^{(5)}(x)}{60}\delta^5 + ...  $$</p>
<p>Now we subtract the two last expressions:</p>
<p>$$ f(x + 2\delta) - f(x - 2\delta) = 4 f'(x) \delta  + \frac{8 f'''(x)}{3}\delta^3 + \frac{8 f^{(5)}(x)}{15}\delta^5 + ...  $$</p>
<p>This means we can get rid of the 3rd order corrections by doing:</p>
<p>$$\frac{2}{3} \left((f(x + \delta)-f(x-\delta ))-\frac{1}{8} (f(x + 2 \delta)-f(x-2 \delta ))\right) = f'(x)\delta -\frac{1}{30} f^{(5)}(x) \delta^5 + O\left(x^6\right)$$</p>
<p>Hence the error term is</p>
<p>$$\frac{1}{30} f^{(5)}(x) \delta^4$$</p>
<p>And the estimate will be</p>
<p>$$\frac{2}{3 \delta} \left((f(x + \delta)-f(x-\delta ))-\frac{1}{8} (f(x + 2 \delta)-f(x-2 \delta ))\right)$$</p>
<h3 id="b">b)</h3>
<p>If the roundoff error is $\epsilon$, then the error is bounded by</p>
<p>$$\frac{2}{3 \delta} \left(\epsilon-(-\epsilon)-\frac{1}{8} ((-\epsilon)-\epsilon)\right) + \frac{1}{30} f^{(5)}(x) \delta^4 = \text{error}$$</p>
<p>$$\frac{2}{3 \delta} \left(2 \epsilon-\frac{\epsilon}{4} \right) + \frac{1}{30} f^{(5)}(x) \delta^4 = \text{error}$$</p>
<p>$$ \frac{7\epsilon}{6 \delta}  + \frac{1}{30} f^{(5)}(x) \delta^4 = \text{error}$$</p>
<p>Taking the derivative with respect to $\delta$ and setting it equal to 0 to minimize it we have:</p>
<p>$$ \frac{d}{d\delta} \left( \frac{7\epsilon}{6 \delta}  + \frac{1}{30} f^{(5)}(x) \delta^4 \right) = 0 $$</p>
<p>$$\frac{2 \delta ^3 k}{15}-\frac{7 \epsilon }{6 \delta ^2} = 0 $$</p>
<p>$$\implies \delta \approx \left( \frac{35 \epsilon}{4 f^{(5)}(x) } \right)^{1/5} $$</p>
<p>So, assuming machine precision is about $10^{-16}$, then we have about</p>
<p>$$\delta \approx 10^{-16/5} \approx 10^{-3.2}$$</p>
<p>We can now try this with code by evaluating the given functions with our derivative. First we create the derivative taking function.</p>
<pre class="hljs"><code><div><span class="hljs-comment"># Function to take the derivative at some point with a given step size</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deriv</span><span class="hljs-params">(func, x0, delta)</span>:</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>/(<span class="hljs-number">3</span>*delta) * (func(x0 + delta) - func(x0 - delta) - <span class="hljs-number">1</span>/<span class="hljs-number">8</span>*(func(x0 + <span class="hljs-number">2</span>*delta) - func(x0 - <span class="hljs-number">2</span>*delta)))
</div></code></pre>
<p>With this function, we can pick a <code>x0</code> and then scan (logarithmically) through different <code>delta</code> values. For the function $e^{x}$ whose derivative is evaluated at $x=0$, this produces the following plot:</p>
<p><img src="figs/q1_error_plot1.jpg" alt="q1_error_plot1"></p>
<p>We can see on it the estimated optimal error is indeed in the $10^{-3}$ ballpark. Also, it was assumed that the fifth derivative is roughly of order 1, which is exactly right for our specific function, since $\frac{d^5}{dx^5} e^x = e^x$.</p>
<p>Now we can try the same procedure, but for the $e^{0.01 x}$ function. Again, we scan the different deltas, and produce the following plot:</p>
<p><img src="figs/q1_error_plot2.jpg" alt="q1_error_plot2"></p>
<p>For this plot the order of magnitude of the 5th derivative was in fact significant since $\frac{d^5}{dx^5} e^x = (0.01)^5e^x$. Hence, the optimal step size had to be divided by $0.01$ and after doing so, we see that it does indeed fall roughly on the minimum of the curve for the error.</p>
<h2 id="question-2">Question 2</h2>
<p>We now code a derivative taking function. We used the centered derivative for that. We simply use the formula</p>
<p>$$\frac{f(x+\Delta x)-f(x - \Delta x)}{2 \Delta x} = f'(x)$$</p>
<p>However, we must pick the appropriate $\Delta x$. If we look at the Taylor expansion of the previous expression, we have</p>
<p>$$f(x + \delta) = f(x) + f'(x) \delta + \frac{f''(x)}{2}\delta^2 + \frac{f'''(x)}{6}\delta^3 + \frac{f^{(4)}(x)}{24}\delta^4 + \frac{f^{(5)}(x)}{120}\delta^5 + ...  $$</p>
<p>$$f(x - \delta) = f(x) - f'(x) + \frac{f''(x)}{2}\delta^2 - \frac{f'''(x)}{6}\delta^3 + \frac{f^{(4)}(x)}{24}\delta^4 - \frac{f^{(5)}(x)}{120}\delta^5 + ...  $$</p>
<p>$$\implies \frac{f(x+\Delta x)-f(x - \Delta x)}{2 \Delta x} = \frac{1}{2 \Delta x}\left( 2 f'(x) \Delta x + \frac{f'''(x)}{3}\Delta x^3\right) + ...$$</p>
<p>$$ =  f'(x)  + \frac{f'''(x)}{6}\Delta x^2 + ...$$</p>
<p>Hence, the error is</p>
<p>$$\text{error} \approx \frac{\epsilon}{\Delta x}  + \frac{f'''(x)}{6}\Delta x^2$$</p>
<p>If we minimize it with respect to $\Delta x$, we have</p>
<p>$$\Delta x \approx \left(\frac{3 \epsilon}{f'''(x)} \right)^{1/3}$$</p>
<p>We will code a function that will find the 3rd derivative with a delta value that is not optimal and then use that derivative to find the first derivative, but this time with a delta that is quite optimal. I am assuming that the error will be relatively small in the 3rd derivative, hence, it should not be too much of a problem since it's only used to roughly find the optimal value for the derivative.</p>
<p>We still need to find some delta to use that is not too far-fetched for the three consecutive derivatives. In class we have seen that to minimize the error for such a derivative prescription (central), we must use $\Delta x \approx 10^{-5}$, assuming second derivatives are not too crazy and that our machine $\epsilon$ is $\approx 10^{-16}$.</p>
<pre class="hljs"><code><div>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ndiff</span><span class="hljs-params">(fun, x, full = False)</span>:</span>
    <span class="hljs-string">'''Function to take a derivate. Optional: can output the estimated error on the result.'''</span>
    
    ini_step = <span class="hljs-number">10</span>**<span class="hljs-number">-5</span> <span class="hljs-comment"># Initial step size (for third derivative)</span>
    
    <span class="hljs-comment"># Anonymous function to take derivatives</span>
    diff_op = <span class="hljs-keyword">lambda</span> func, x: (func(x + ini_step) - func(x - ini_step))/(<span class="hljs-number">2</span>*ini_step)

    deriv_1 = <span class="hljs-keyword">lambda</span> x: diff_op(fun, x)     <span class="hljs-comment"># Calculating the first derivative</span>
    deriv_2 = <span class="hljs-keyword">lambda</span> x: diff_op(deriv_1, x) <span class="hljs-comment"># Calculating the second derivative</span>
    deriv_3 = <span class="hljs-keyword">lambda</span> x: diff_op(deriv_1, x) <span class="hljs-comment"># Calculating the thirs derivative</span>
    
    <span class="hljs-comment"># Optimal step size</span>
    third_deriv = deriv_3(x)
    print(third_deriv)
    opt_step = (abs(<span class="hljs-number">3</span>*np.finfo(float).eps/third_deriv))**(<span class="hljs-number">1</span>/<span class="hljs-number">3</span>)
    
    <span class="hljs-comment"># Finding the derivative</span>
    deriv = (fun(x + opt_step) - fun(x - opt_step))/(<span class="hljs-number">2</span>*opt_step)

    <span class="hljs-comment"># Conditional system for optional argument</span>
    <span class="hljs-keyword">if</span> full:
        <span class="hljs-comment"># Returns derivative and estimated error</span>
        est_err = np.finfo(float).eps/opt_step + third_deriv*opt_step**<span class="hljs-number">2</span>/<span class="hljs-number">6</span>
        <span class="hljs-keyword">return</span> np.array([deriv, est_err])
    
    <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> full:
        <span class="hljs-comment"># Returns only derivative</span>
        <span class="hljs-keyword">return</span> deriv
</div></code></pre>
<h2 id="question-3">Question 3</h2>
<p>To answer this question we create the following function</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lakeshore</span><span class="hljs-params">(V, data)</span>:</span>
    <span class="hljs-string">'''Function to interpolate the data with a cubic spline'''</span>
    temperatures = np.array([i[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> data[::<span class="hljs-number">-1</span>]]) <span class="hljs-comment"># Making array for temperatures (from raw data)</span>
    voltages = np.array([i[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> data[::<span class="hljs-number">-1</span>]]) <span class="hljs-comment"># Making array for volatages (from raw data)</span>
    approx_vol_size = abs(voltages[<span class="hljs-number">2</span>]-voltages[<span class="hljs-number">1</span>])
    
    <span class="hljs-comment"># First we find the interpolation</span>
    cs = sci.interpolate.CubicSpline(voltages, temperatures) <span class="hljs-comment"># spline function</span>
    inter_val = cs(V)

    <span class="hljs-comment"># Now we roughly estimate the error</span>
    lin_spline = sci.interpolate.interp1d(voltages, temperatures) <span class="hljs-comment"># Linear interpolation</span>
    err_range = np.array(np.linspace(V-approx_vol_size, V+approx_vol_size, <span class="hljs-number">1000</span>))

    approx_error = np.std(abs(lin_spline(err_range) - cs(err_range)), axis = <span class="hljs-number">0</span>)


    <span class="hljs-keyword">return</span> inter_val, approx_error
</div></code></pre>
<p>This function takes as input the value(s) we want to evaluate at an interpolated value and the raw data to create the interpolation. The function starts by extracting arrays for the temperature and the voltages from the raw data. From these $x$ and $y$ set of data, we are able to create the interpolation. To find the error on the obtained values, we create another interpolation, but this time linear. We look at the difference between the linear and the cubic splined interpolations to obtain a rough estimate for the error. This difference should give us roughly an order of magnitude estimate of the error. The rationale behinnd it is that the cubic spline can be &quot;curvier&quot; than the actual data, while the linear fit is often not curvy enough, hence the true value is hypothesized to fall within the two fit. This is where this substraction came from.</p>
<p>All this is down with arrays, so the function can work with both single value or arrays for <code>V</code>. It will return two elements, the first is either an array or single value for the interpolated value and the second is the rough estimate for the error (also as array or value).</p>
<p>The interpolation can be observed in the following plot:</p>
<p><img src="figs/q3_interp_plot.jpg" alt="q3_interp_plot"></p>
<h2 id="question-4">Question 4</h2>
<h3 id="cos-x">$\cos (x)$</h3>
<p>We create three different interpolations for samples of the $\cos (x)$ function.</p>
<p>The first is a polynomial fit of degree $n-1$ where $n$ is the number of samples used. <code>scipy</code>'s <code>polyfit</code> function was used for that.</p>
<p>The second interpolation scheme used was a cubic spine. Similarly to the polynomial fit, we used <code>scipy</code>'s <code>polyfit</code>'s <code>interpolate.CubicSpline</code> function.</p>
<h3 id="lorentzian">Lorentzian</h3>

</body>
</html>
